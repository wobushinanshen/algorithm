#include<bits/stdc++.h>
using namespace std;
//A：ST表是什么
//B：目前我也不是很懂啊，但是我会基本的操作，至于什么时候要用……
//A：那操作是什么
//B：其实还是有一个小引入可以理解ST表是用来干什么的
//   给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间内数字的最大值。
//   每次询问会输入左右区间l,r
//   你需要输出[l，r]下标对应数组区间的最大值
//   这时候你会想到暴力，但是不出意外肯定会被卡的，毕竟暴力能过的话，这题就没有含金量了
//A：那怎么办？
//B：有一个以空间换时间的做法，欸，是不是很熟悉，有没有想到记忆化搜索
//A：难道？
//B：没错，ST表其实也是DP的一种实现，通过预处理(即构建一个查询表格),后面的查询操作都可以做到O1的复杂度
//A：那要怎么操作
//B：可以想象一个二维的表格，上面的每一个格子用st[i][j]来表示，那么st[i][j]就表示以第i个元素为开头，
//   长度为2^j的区间的最值，也就是a[i]--a[i+2^j-1]区间的最值

//   2^0  2^1  2^2  2^3  2^4 .. (第j列表示2的j次方)
//1  a[1]
//2  a[2]
//3  a[3]
//4  a[4]
//.  
//n
//(第i行表示以第i个元素为开头)
//其中第一列的值是已知的，就是数组的值，因为st[i][0]是以i为开头，1为长度的区间的最大值，对应就是数组中的每个数(因为只有一个数了)

//   理解了这张表的内涵后，可以开始我们的第一步：构建ST表(这一步你会觉得很dp)
//   首先初始条件是知道的，即第1列的内容，现在就是由这一列来推出表格里其他位置(这就是自底向顶的操作)
//   怎么推->状态转移方程：s[t][j]=max(st[i][j-1],st[i+(1<<(j-1))])[j-1];
//   怎么解释：分治思想，很好理解，不多说了。

//A：有了这张表，要怎么用呢，我要查下标为l,r的区间的最大值，这张表好像没有总结出所有情况吧，
//   而是利用了倍增，罗列了2的次方为长度的情况，那我要查长度为3 5的又怎么办，一定有一个查询的方法吧
//B：很好，这就是第二步：查询
//   你要查l，r的最大值，确实st表中没有所有情况，因此有一个技巧：
//   首先，你要先找到一个k值，使得2^k<= r-l+1 <2^(k+1)
//   这个k的意思是：2^k要小于等于要求区间的长度，并且k要尽量大,比如要求[1,5]，那么k就取2(大了或小了都不行)
//   这样一来，[l,2^k]并上[r-2^k+1,r]就可以完全覆盖[l,r]区间了，有重合也没关系(因为对求最值并没有影响)
//   所以输入[l,r]-->返回max(st[l,k],st[r-2^k+1,k])
//A；酣畅淋漓

//下面来做洛谷3865模板题
long long a[100010];
const int maxn=1e5+10;
int st[100010][18];
int n,m;
//构建st表
void build(){
    for(int i=1;i<=n;i++){
        st[i][0]=a[i];
    }
    for(int j=1;j<18;j++){
        for(int i=1;i+(1<<j)-1<=n;i++){
            st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);//状态转移
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    build();
    int l=0,r=0;
    while(m--){
        cin>>l>>r;
        int temp=r-l+1;
        //找一个k值
        int k=log2(temp);
        int ans=max(st[l][k],st[r-(1<<k)+1][k]);//查询表达式
        cout<<ans<<"\n";
    }

}
