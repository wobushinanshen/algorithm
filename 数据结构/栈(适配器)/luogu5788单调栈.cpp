#include<iostream>
#include<stack>
#include<vector>
using namespace std;
//A：单调栈，是啥？跟栈有什么区别吗
//B：单调栈，顾名思义，就是确保栈内元素保持单调的一个栈(如果栈存的是下标，那么就是下表对应的数保持单调)
//   单调栈的实现=栈的操作+手写控制行为
//   由单调栈的特性可以知道，单调栈最经典的使用场景，是：存在一个序列，利用单调栈，可以对于每个元素，求其
//   左侧比它小，并且距离最近的元素在哪，右侧比它小，并且距离最近的元素在哪
//   左侧比它大，并且距离最近的元素在哪，右侧比它大，并且距离最近的元素在哪
//   关键是：距离最近。
//A：为什么可以做到这样？单调栈到底有什么特性
//B：首先，单调栈是你往栈里面输入元素的时候，你要刻意去保持单调，
//   怎么做到呢，很简单，只要出现破坏栈内元素单调性的数的时候，就堆栈内的元素进行pop弹出
//   直到把当前元素放到栈顶也不影响单调性或者栈空为止
//   现在举个例子，比如你要找一个序列每个元素左右两侧第一个大于该元素的元素在哪，
//   你可以维护一个单调递减的栈，将序列的元素的下标依次输入栈顶(存下标更方便)
//   假设现在栈内元素(指的是下标对应的元素)是：bcd(d是栈顶，此时b>c>d)，
//   当序列下一个元素a(假设b>c>a>d)会破坏栈内单调递减时
//   把栈顶元素弹出，即d弹出，此时把a放入又可以维持单调递减了，那么对弹出的d就可以收集答案了
//   d左侧第一个比d大的数就是c，而右侧第一个比d大的数就是让d弹出的元素a，
//   这里注意一点：可能会存在弹出多个元素的情况(比如b>a>c>d时cd都要弹出)，
//   因此，每弹出一个元素，就要记录它的答案了
//   直到没有元素弹出后，再把a放到栈顶
//   这样就根据下标记录了部分元素的答案了
//   为什么说部分，因为最后栈内一定还有元素
//   接着处理一下即可

//   废话不多说，直接实现--洛谷5788
long long arr[3000010];
int ans[3000010];

int main(){
    stack<int> s;
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>arr[i];
    }
    //输入数组，没啥好说
    s.push(1);//先给s push第一个数
    for(int i=2;i<=n;i++){//从2开始
        //注意，栈存的是下标
        while(!s.empty()&&arr[s.top()] <arr[i]){
            ans[s.top()]=i;
            s.pop();

        }
        //s不空并且新元素的加入会破坏原有栈内元素的单调性时，弹出队列元素
        //直至新元素插入不影响单调性，或者栈为空
        s.push(i);
        //等到弹出操作结束后，再将新元素加入栈

    }
    //最后栈内会剩下一些没弹出的元素，这说明他们后面都没有比他们大的元素了，不然他们早就弹出了
    //所以都赋值为0
    while(!s.empty()){
        ans[s.top()]=0;
        s.pop();//记录一个，就弹出一个
    }

    for(int i=1;i<=n;i++){
        cout<<ans[i]<<" ";
    }

}