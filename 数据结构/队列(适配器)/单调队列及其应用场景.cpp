#include<iostream>
using namespace std;
//首先说一下单调队列是用来解决什么问题的//
//---->单调队列的应用场景<----//
// 单调队列常用于解决以下问题：
// 1、滑动窗口的最值问题：
// 给定一个数组和一个固定大小的窗口，求每个窗口中的最大值或最小值。

// 2、优化动态规划问题：
// 在某些动态规划问题中，单调队列可以用于优化状态转移方程，减少时间复杂度。
//需要清楚的是：单调队列不会考模板题，而是常常用于优化dp

//现在以滑动窗口最大最小值为例，介绍一下单调队列的模板


//A：我知道了单调队列的特性，就是要维护一个单调窗口，但是我有一个疑问，就是对于这道题，
//   我怎么去收集答案呢？
//B：首先，单调队列的核心是一句话"如果别人比你小，还比你强，那你就没希望了",
//   以最大值为例，这句话的意思是，如果在你后面的元素，还比你更大，那你在有生之年就没有办法成为最大值了
//   因此，当元素从队尾入队，要考虑一件事情，就是它能淘汰掉已经在队列中的多少元素呢
//   这里就可以用一个while循环来实现吧，作用是一直判断，直到即将入队的元素遇到比自己大的元素，
//   (这里都是以最大值为例)或者队列已经没有元素了，这时候这个元素就该入队了
//   因此，这样就维护了一个单调递减的队列，并且"每次加入一个元素后"，队首元素就是窗口内的最大值
//   到这里，之前有的疑问就解决了，怎么收集答案呢，现在不是很明确了吗(虽然我也不知道之前怎么没想通捏)
//   回到正题，答案收集：每进行一次最外层循环(也就是每有一个元素入队了)，然后经过前面的操作，
//   就可以确定当前队列的队首元素就是这次的窗口的最大值。
//   就比如，现在已经有了两个元素,5 4,接下来是元素6入队，那5 4要弹出，6就是队首
//   6就是当前窗口的最大值，你不用管队列中还剩下多少个元素，因为每进行一次外层循环，其实就是窗口在
//   向右滑动了，现在根据上面的结论就可以得出队首就是最大值
//A：噢，这我就懂了。
//B：对吧，接下来就是一些细节的实现，嗯……，按照我的习惯，我一般喜欢先形成一个长度为k-1的窗口
//   这样方便待会直接收集答案
//   还有一件事，就是可以把数组和队列分开去理解
//   心里要清楚，数组没有那么多花里胡哨，它就是存在一个窗口一直在往右移动，
//   注意dq不是用来存数的，而是用来存下标的。
long long arr[1000010];
int dq[1000010];
long long ans[1000010];
int n,k;
//这是一种实现方式,来求最大
void max_(){
    
    int h=0,t=0;//先定义队列的head,tail
    //这里是先形成k-1长度窗口，注意记录tail的位置,
    for(int i=0;i<k-1;i++){
        while(h<t&&arr[i]>=arr[dq[t-1]]){
            t--;
        }
        dq[t++]=i;
    }
    int m=n-k+1;//一共就是m个最大值，进行m次循环就够了吧，因为收集m个答案嘛，每次循环收集一个答案
    //最大值为例
    for(int l=0,r=k-1;l<m;l++,r++){//这里定义的l待会有两个用处：作为答案数组的下标，检查是否过期
        while(h<t&&arr[r]>=arr[dq[t-1]]){//当即将入队的数大于队尾的数时，队尾弹出，对应操作就是t--
            t--;//可能会问t--了，但是dq[t]本身还在啊，没关系，因为会被后面的元素覆盖掉，因此
                //不用想太多，就直接把t--这个操作认为是将队尾元素弹出即可
        }
        dq[t++]=r;//弹出了能被弹出的所有队尾元素后(或者队列为空)，当前的元素入队，并将t++
        ans[l]=arr[dq[h]];//收集答案
        if(dq[h]==l){
            h++;
        }
        //这里dq[h]==l什么意思呢
        //首先他的作用是判断首元素是否过期
        //实现原理是：因为dq记录的是数组的下标，而且我们清楚数组的窗口是一直在向右移动的
        //           所以当dq[h]所记录的下标等于窗口左边界时，就说明这个数已经过期
        //           换句话说，这个数在数组中已经离开窗口了，再用它当最大值已经没有意义了
        
    }
    
    for(int i=0;i<m;i++){
        cout<<ans[i]<<" ";
    }
}
//这里用另一种方式(就是不用先形成窗口)求最小(其实没什么区别，核心是相同的，只是一些细节处理不同)
int arr1[1000010];
int dq1[1000010];
long long ans1[1000010];
void min_(){
    int h=1,t=0;//数组从1开始存，因此h一开始定义为1
    for(int i=1;i<=n;i++){
        while(h<=t&&arr1[i]<=arr1[dq1[t]]){//h<=t才说明队列中有元素
            t--;
        }
        dq1[++t]=i;//先++，再让元素入队
        while(h<=t&&dq1[h]+k<=i){
            h++;//判断是否过期，即h上的下标加上k是否还比i小，如果是，就说明该下标所对应的元素已经过期了
        }
        if(i>=k){//注意i其实可以理解是在数组上的右移操作，当i>=k时，说明窗口已经形成，可以开始打印了
            cout<<arr1[dq1[h]]<<" ";
        }
        
    }
    

}
int main(){
    cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    for(int i=1;i<=n;i++){
        cin>>arr1[i];
    }
    //输入数据，没啥好说
    min_();
    cout<<"\n";
    max_();
    
}