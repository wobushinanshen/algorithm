#include<iostream>
using namespace std;
//A:终于要学习递归了吗
//B：首先，说一下递归其实不算一种算法，但是递归对实现dp很有帮助，一个dp题，它必然有暴力递归的实现方式
//   所以学会递归先，便可以从递归入门dp
//A：我了解过递归，但是总数很难理解code，咋办
//B：很正常，因为你没有进行系统化训练，也不知道递归的做题步骤，以及递归前的准备工作。
//A；求赐教
//B：首先有个人曾经说过，递归的核心其实就是遍历，只不过和平时的线性遍历不同，递归是把每个问题分解为子问题
//   并且主问题和子问题具有相同的特点，比如斐波那契数列，f(5)->f(4)+f(3),
//   求f(5)分解为求f(4)和f(3),那求f(4)和f(3)其实也是继续分解，那他们是不是有相同的特点呀
//A：嗯
//B：那是不是可以先假设一个函数f，假设f可以去实现一个功能:就是代入n的时候，这个函数可以把第n个斐波那契数
//   求出来，不用想怎么去实现这个函数，就先默认它可以实现这个功能即可
//A: ok
//B: 然后，你现在去定义一个函数F，参数是n，表示要求第n个斐波那契数
//A: 好了，然后呢
//B：那么现在，你把现在的F函数就想象成之前的f函数，去写一个式子来求第n个斐波那契数
//A: 如果把F当作f，那么根据f的功能，我可以写出return F(n-1)+F(n-2),这样吗。
//B：没错！接下来，你一定有一个疑问，就是F(5)交给F(3)和F(4),那F(3)和F(4)交给更下面的
//   总得有个头吧，这个头就是所谓的base case,即结束条件
//   你知道斐波那契数列前两项了吧，那么当n==1或者n==2的时候，就可以写一个if语句，返回他们对应的值
//A:这样吗
//B：没错，现在你已经完成了一个递归函数了，运行试试吧
int F(int n){
    if(n==1||n==2)return 1;
    return F(n-1)+F(n-2);
}
int main(){
    cout<<F(6);

}