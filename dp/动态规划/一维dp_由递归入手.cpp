#include<iostream>
using namespace std;
//斐波那契数

//A: 这个我会，可以用递归。
//B：有没有想过递归的时间复杂度，高达2^n，因为递归重复算了很多子问题，比如求f(5)时算了一次f(4),求f(6)的时候也算了
//   一次f(4)
//A: 嗯……那怎么办？
//B：可以将递归改为dp哦。
//A：dp？那是啥？

//f1:暴力递归
int f1(int n){
    if(n==0)return 0;
    if(n==1)return 1;
    return f1(n-1)+f1(n-2);

}
//B:dp就是动态规划，它具体是一种思想，通常在递归中体现，两者经常绑定出现，具体是一种什么思想呢？先别急，看下面这个做法。

//f2:dp思想，通过构建存款表，实现记忆化搜索，让"递归"变成"dp"
//记忆化搜索
int f2(int n,int dp[]){
    if(n==0)return 0;
    if(n==1)return 1;
    if(dp[n]!=-1)return dp[n];
    int ans=f2(n-1,dp)+f2(n-2,dp);
    dp[n]=ans;
    return ans;
}

//B：这个f2做法复杂度是O(n)，因为dp数组将凡是已经算过结果的子问题记着，当每次递归的时候，通过if语句判断dp[n]是否被
//    赋值过，所以解决了重复计算的问题。

//A: 所以这就是dp吗？
//B：没错，这种方法叫做记忆化搜索，属于dp的一种，你可以发现它是由顶到底来计算的吧，比如f(7)->f(6)+f(5),这是记忆化搜索的
//   特点
//A：妙啊，我怎么想不到这样做呢。
//B：这是因为你还不理解动态规划，动态规划的思想可以总结为：1、“聪明地”递归，不重复计算。2、把复杂问题分解为一系列子问题。
//  是不是和递归很像，其实递归是暴力版分解问题，而动态规划更聪明。
//  其实dp题就是可以从递归入手，一般解题顺序：递归入手，加入记忆化，再去尝试能不能换为从底到顶的表格法 做法。
//  所以任何动态规划题都一定对应着一个有重复调用行为的递归
//  任何动态规划的题目都一定可以从递归入手，逐渐实现动态规划。因此将一道dp题分为：暴力递归，尝试记忆化搜索去重叠子，再看
//  能不能写成

//f3 :从底到顶的dp
int f3(int n){
    int last=1,lastlast=0;
    int res=0;
    for(int i=2;i<=n;i++){
        res=last+lastlast;
        lastlast=last;
        last=res;
    }
    return last;

}
int main(){
    int n=10;
    cout<<"f1:"<<f1(n)<<endl;
    int dp[100];//构建一个“备忘录”
    for(int i=0;i<100;i++){
        dp[i]=-1;
    }
    cout<<"f2:"<<f2(n,dp)<<endl;
    cout<<"f3:"<<f3(n)<<endl;
}